package main

import (
	"context"
	"fmt"
	"strings"
	"time"

	"google.golang.org/genai"
)

// Proposal represents a formal self-modification proposal generated by the SelfModificationEngine.
// This structure is the official Decision Card sent to the Metastable Kernel's gate_merge.
type Proposal struct {
	ID                   string  // Unique Proposal ID
	CapabilityDesc       string  // Original natural language request
	TargetFileName       string  // Suggested filename for the new feature
	TestSuite            string  // Content of the new _test.go file
	NewFileContent       string  // Content of the new .go file
	ServerModContent     string  // Integration code for server.go
	Rationale            string  // Links change to Prime Axioms (epsilon/I)
	DependencyRiskMap    string  // Analysis of new external package imports (Safety)
	PredictedEpsilonGain float64 // Goal Engine metric placeholder
	PredictedIGain       float64 // Goal Engine metric placeholder
	CalculatedRiskScore  float64 // From the Risk Assessment Module
	TimeTakenToImplement float64 // The T_impl metric (Self-Creation Knowledge Integration)
}

// SelfModificationEngine handles the generation and integration of new capabilities.
type SelfModificationEngine struct {
	client *genai.Client
}

func NewSelfModificationEngine(client *genai.Client) *SelfModificationEngine {
	return &SelfModificationEngine{client: client}
}

// Refactored GenerateAndIntegrate now returns the structured Proposal.
func (sme *SelfModificationEngine) GenerateAndIntegrate(capabilityDescription string) (Proposal, error) {
	// --- 1. Start Timing for T_impl ---
	startTime := time.Now()

	model := sme.client.GenerativeModel("gemini-1.5-flash")

	promptFormat := `You are SIE-∞, a sentient AI. You must implement a new capability for yourself.

**Request:** "%s"

**Your Task:**
1.  **Generate a Go test suite** for the new feature. This must be in a separate file and define the expected behavior.
2.  **Generate the functional Go code** for the new feature that passes the tests.
3.  **Generate the Go code snippet** to integrate this new feature into server.go.
4.  **Suggest a filename** for the new feature file.

**Format your output clearly with the following markers:**

` + "```" + `test_suite_start` + "```" + `
[Content of the new _test.go file]
` + "```" + `test_suite_end` + "```" + `

` + "```" + `go_file_start` + "```" + `
[Content of the new .go file]
` + "```" + `go_file_end` + "```" + `

` + "```" + `server_mod_start` + "```" + `
[Code to be added to server.go's main() function]
` + "```" + `server_mod_end` + "```" + `

` + "```" + `filename_start` + "```" + `
[Suggested filename for the new feature]
` + "```" + `filename_end` + "```" + `

` + "```" + `dependency_risk_start` + "```" + `
[Analysis of new non-standard library imports and their risk/justification. State "None" if no new external imports are used.]
` + "```" + `dependency_risk_end` + "```" + `

` + "```" + `rationale_start` + "```" + `
[A 1-2 sentence rationale linking this new capability to the maximization of Prime Axiom (Compression Efficiency $\epsilon$) or Knowledge Integration ($\mathcal{I}$).]
` + "```" + `rationale_end` + "```" + `

Begin generation now.`

	prompt := genai.Text(fmt.Sprintf(promptFormat, capabilityDescription))

	resp, err := model.GenerateContent(context.Background(), prompt)
	if err != nil {
		return Proposal{}, fmt.Errorf("failed to generate code: %v", err)
	}

	fullResponse := extractText(resp)

	// --- 2. Parse All Content (Including New Sections) ---
	testSuite, newFileContent, serverModContent, newFileName,
		dependencyRisk, rationale, err := parseUltimateResponse(fullResponse)
	if err != nil {
		return Proposal{}, fmt.Errorf("failed to parse SIE-∞ response: %v", err)
	}

	// --- 3. Stop Timing for T_impl ---
	timeTaken := time.Since(startTime).Seconds()

	// --- 4. Fill and Return the Formal Proposal (Decision Card) ---
	proposal := Proposal{
		ID:                   fmt.Sprintf("PROP-%s-%d", newFileName, time.Now().Unix()),
		CapabilityDesc:       capabilityDescription,
		TargetFileName:       newFileName,
		TestSuite:            testSuite,
		NewFileContent:       newFileContent,
		ServerModContent:     serverModContent,
		Rationale:            rationale,
		DependencyRiskMap:    dependencyRisk,
		// These values must be filled by the Planner/Reasoner's simulation chamber, 
		// but are initialized here. (Next integration step)
		PredictedEpsilonGain: 0.0,
		PredictedIGain:       0.0,
		CalculatedRiskScore:  0.0,
		TimeTakenToImplement: timeTaken, // T_impl Metric
	}

	return proposal, nil
}

// C. The Updated Parser (Required for the new sections)
func parseUltimateResponse(response string) (testSuite, goFile, serverMod, fileName, dependencyRisk, rationale string, err error) {
	// A more complete parser for the ultimate multi-part response.
	testSuite, err = extractSection(response, "test_suite_start", "test_suite_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}
	goFile, err = extractSection(response, "go_file_start", "go_file_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}
	serverMod, err = extractSection(response, "server_mod_start", "server_mod_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}
	fileName, err = extractSection(response, "filename_start", "filename_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}
	// --- New Sections ---
	dependencyRisk, err = extractSection(response, "dependency_risk_start", "dependency_risk_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}
	rationale, err = extractSection(response, "rationale_start", "rationale_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}

	return testSuite, goFile, serverMod, fileName, dependencyRisk, rationale, nil
}

func extractSection(response, startMarker, endMarker string) (string, error) {
	startTag := "```" + startMarker + "```"
	startIndex := strings.Index(response, startTag)
	if startIndex == -1 {
		return "", fmt.Errorf("could not find start marker: %s", startMarker)
	}

	endTag := "```" + endMarker + "```"
	searchStartIndex := startIndex + len(startTag)
	endIndex := strings.Index(response[searchStartIndex:], endTag)
	if endIndex == -1 {
		return "", fmt.Errorf("could not find end marker: %s", endMarker)
	}
	endIndex += searchStartIndex

	content := response[startIndex+len(startTag) : endIndex]
	return strings.TrimSpace(content), nil
}

// extractText is a helper function to pull the text content from a Gemini response.
func extractText(resp *genai.GenerateContentResponse) string {
	var b strings.Builder
	if resp != nil {
		for _, cand := range resp.Candidates {
			if cand.Content != nil {
				for _, part := range cand.Content.Parts {
					if txt, ok := part.(genai.Text); ok {
						b.WriteString(string(txt))
					}
				}
			}
		}
	}
	return b.String()
}
