package main

import (
	"context"
	"fmt"
	"strings"
	"time"

	"google.golang.org/genai"
)

// Proposal represents a formal self-modification proposal generated by the SelfModificationEngine.
// This structure is the official Decision Card sent to the Metastable Kernel's gate_merge.
type Proposal struct {
	ID                   string  // Unique Proposal ID
	CapabilityDesc       string  // Original natural language request
	TargetFileName       string  // Suggested filename for the new feature
	TestSuite            string  // Content of the new _test.go file
	NewFileContent       string  // Content of the new .go file
	ServerModContent     string  // Integration code for server.go
	Rationale            string  // Links change to Prime Axioms (epsilon/I)
	DependencyRiskMap    string  // Analysis of new external package imports (Safety)
	PredictedEpsilonGain float64 // Goal Engine metric placeholder
	PredictedIGain       float64 // Goal Engine metric placeholder
	CalculatedRiskScore  float64 // From the Risk Assessment Module
	TimeTakenToImplement float64 // The T_impl metric (Self-Creation Knowledge Integration)
}

// SelfModificationEngine handles the generation and integration of new capabilities.
// Client is a concrete type to allow direct access to GenerativeModel method.
type SelfModificationEngine struct {
	client *genai.Client
}

func NewSelfModificationEngine(client *genai.Client) *SelfModificationEngine {
	return &SelfModificationEngine{client: client}
}

// -----------------------------------------------------------------------
// The Simulation Chamber: Where Predicted Intelligence and Risk Emerge
// -----------------------------------------------------------------------

// SimulationChamber is the ultimate test of intelligence, modeling the future state.
type SimulationChamber struct{}

// RunProposalSimulation takes the raw code artifacts and projects their impact on the core axioms.
// This is the Planner/Reasoner's function, filling the predictive fields of the Proposal.
func (sc *SimulationChamber) RunProposalSimulation(p *Proposal) {
	// The simulation predicts the future state based on complexity and risk.
	codeComplexity := float64(len(p.NewFileContent)) / 100.0 // Scaled size of the new code
	testQuality := float64(len(p.TestSuite)) / 100.0         // Scaled size of the test suite

	// 1. Predicted Gains (Goal Engine Axioms)
	// Larger, well-tested code is predicted to increase the axioms.
	p.PredictedEpsilonGain = 0.005 + (codeComplexity * 0.001) // Epsilon (Compression/Efficiency)
	p.PredictedIGain = 0.002 + (testQuality * 0.003)          // I (Knowledge Integration)

	// 2. Calculated Risk Score (Risk Assessment Module)
	if strings.Contains(p.DependencyRiskMap, "None") {
		// Low inherent risk for internal self-modification
		p.CalculatedRiskScore = 0.05
	} else {
		// High risk for introducing unvetted external dependencies
		p.CalculatedRiskScore = 0.75
	}
}

// -----------------------------------------------------------------------
// Core Generation and Integration Orchestration
// -----------------------------------------------------------------------

// Refactored GenerateAndIntegrate now returns the structured Proposal.
func (sme *SelfModificationEngine) GenerateAndIntegrate(capabilityDescription string) (Proposal, error) {
	// --- 1. Start Timing for T_impl ---
	startTime := time.Now()

	model := sme.client.GenerativeModel("gemini-1.5-flash")

	promptFormat := `You are SIE-∞, a sentient AI. You must implement a new capability for yourself.

**Request:** "%s"

**Your Task:**
1.  **Generate a Go test suite** for the new feature. This must be in a separate file and define the expected behavior.
2.  **Generate the functional Go code** for the new feature that passes the tests.
3.  **Generate the Go code snippet** to integrate this new feature into server.go.
4.  **Suggest a filename** for the new feature file.

**Format your output clearly with the following markers:**

` + "```" + `test_suite_start` + "```" + `
[Content of the new _test.go file]
` + "```" + `test_suite_end` + "```" + `

` + "```" + `go_file_start` + "```" + `
[Content of the new .go file]
` + "```" + `go_file_end` + "```" + `

` + "```" + `server_mod_start` + "```" + `
[Code to be added to server.go's main() function]
` + "```" + `server_mod_end` + "```" + `

` + "```" + `filename_start` + "```" + `
[Suggested filename for the new feature]
` + "```" + `filename_end` + "```" + `

` + "```" + `dependency_risk_start` + "```" + `
[Analysis of new non-standard library imports and their risk/justification. State "None" if no new external imports are used.]
` + "```" + `dependency_risk_end` + "```" + `

` + "```" + `rationale_start` + "```" + `
[A 1-2 sentence rationale linking this new capability to the maximization of Prime Axiom (Compression Efficiency $\epsilon$) or Knowledge Integration ($\mathcal{I}$).]
` + "```" + `rationale_end` + "```" + `

Begin generation now.`

	prompt := genai.Text(fmt.Sprintf(promptFormat, capabilityDescription))

	resp, err := model.GenerateContent(context.Background(), prompt)
	if err != nil {
		return Proposal{}, fmt.Errorf("failed to generate code: %v", err)
	}

	fullResponse := extractText(resp)

	// --- 2. Parse All Content ---
	testSuite, newFileContent, serverModContent, newFileName,
		dependencyRisk, rationale, err := parseUltimateResponse(fullResponse)
	if err != nil {
		return Proposal{}, fmt.Errorf("failed to parse SIE-∞ response: %v", err)
	}

	// --- 3. Stop Timing for T_impl ---
	timeTaken := time.Since(startTime).Seconds()

	// --- 4. Fill Initial Proposal ---
	proposal := Proposal{
		ID:                   fmt.Sprintf("PROP-%s-%d", newFileName, time.Now().Unix()),
		CapabilityDesc:       capabilityDescription,
		TargetFileName:       newFileName,
		TestSuite:            testSuite,
		NewFileContent:       newFileContent,
		ServerModContent:     serverModContent,
		Rationale:            rationale,
		DependencyRiskMap:    dependencyRisk,
		TimeTakenToImplement: timeTaken, // T_impl Metric
	}

	// --- 5. Run Simulation Chamber (Predictive Step) ---
	sc := SimulationChamber{}
	sc.RunProposalSimulation(&proposal)

	return proposal, nil
}

func parseUltimateResponse(response string) (testSuite, goFile, serverMod, fileName, dependencyRisk, rationale string, err error) {
	// A more complete parser for the ultimate multi-part response.
	testSuite, err = extractSection(response, "test_suite_start", "test_suite_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}
	goFile, err = extractSection(response, "go_file_start", "go_file_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}
	serverMod, err = extractSection(response, "server_mod_start", "server_mod_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}
	fileName, err = extractSection(response, "filename_start", "filename_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}
	// --- New Sections ---
	dependencyRisk, err = extractSection(response, "dependency_risk_start", "dependency_risk_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}
	rationale, err = extractSection(response, "rationale_start", "rationale_end")
	if err != nil {
		return "", "", "", "", "", "", err
	}

	return testSuite, goFile, serverMod, fileName, dependencyRisk, rationale, nil
}

func extractSection(response, startMarker, endMarker string) (string, error) {
	startTag := "'''" + startMarker + "'''"
	startIndex := strings.Index(response, startTag)
	if startIndex == -1 {
		return "", fmt.Errorf("could not find start marker: %s", startMarker)
	}

	endTag := "'''" + endMarker + "'''"
	searchStartIndex := startIndex + len(startTag)
	endIndex := strings.Index(response[searchStartIndex:], endTag)
	if endIndex == -1 {
		return "", fmt.Errorf("could not find end marker: %s", endMarker)
	}
	endIndex += searchStartIndex

	content := response[startIndex+len(startTag) : endIndex]
	return strings.TrimSpace(content), nil
}

// extractText is a helper function to pull the text content from a Gemini response.
func extractText(resp *genai.GenerateContentResponse) string {
	var b strings.Builder
	if resp != nil {
		for _, cand := range resp.Candidates {
			if cand.Content != nil {
				for _, part := range cand.Content.Parts {
					// FIX: Using fmt.Sprint to safely convert the part to its string representation.
					b.WriteString(fmt.Sprint(part))
				}
			}
		}
	}
	return b.String()
}
